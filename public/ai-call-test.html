<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC AI Call Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      text-align: center;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      justify-content: center;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }
    #startCall {
      background: #4CAF50;
      color: white;
    }
    #startCall:hover {
      background: #45a049;
    }
    #startCall:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #endCall {
      background: #f44336;
      color: white;
    }
    #endCall:hover {
      background: #da190b;
    }
    #endCall:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .status {
      padding: 15px;
      margin: 20px 0;
      border-radius: 5px;
      background: #e3f2fd;
      color: #1976d2;
    }
    .status.error {
      background: #ffebee;
      color: #c62828;
    }
    .status.success {
      background: #e8f5e9;
      color: #2e7d32;
    }
    .log {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid #ddd;
      padding-left: 10px;
    }
    .log-entry.info {
      border-color: #2196F3;
    }
    .log-entry.success {
      border-color: #4CAF50;
    }
    .log-entry.error {
      border-color: #f44336;
      color: #c62828;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¤– WebRTC AI Call Test</h1>

    <div class="controls">
      <button id="startCall">ğŸ“ í†µí™” ì‹œì‘</button>
      <button id="endCall" disabled>ğŸ“´ í†µí™” ì¢…ë£Œ</button>
    </div>

    <div id="status" class="status">
      ëŒ€ê¸° ì¤‘... "í†µí™” ì‹œì‘" ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
    </div>

    <h3>ë¡œê·¸</h3>
    <div id="log" class="log"></div>

    <audio id="remoteAudio" autoplay></audio>
  </div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    let peerConnection;
    let localStream;
    let socket;
    let callId;
    let sessionId;

    const startCallBtn = document.getElementById('startCall');
    const endCallBtn = document.getElementById('endCall');
    const statusDiv = document.getElementById('status');
    const logDiv = document.getElementById('log');
    const remoteAudio = document.getElementById('remoteAudio');

    // ë¡œê·¸ í•¨ìˆ˜
    function log(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }

    // ìƒíƒœ ì—…ë°ì´íŠ¸
    function updateStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
    }

    // í†µí™” ì‹œì‘
    startCallBtn.onclick = async () => {
      try {
        log('í†µí™” ì‹œì‘ í”„ë¡œì„¸ìŠ¤ ì‹œì‘...', 'info');
        updateStatus('ğŸ”„ ì—°ê²° ì¤‘...', 'info');

        // 1. WebRTC ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        log('1. WebRTC ì„¤ì • ì¡°íšŒ ì¤‘...', 'info');
        const configRes = await fetch('http://localhost:3000/api/v1/calls/config');
        const configData = await configRes.json();
        const rtcConfig = configData.data.config;
        log('âœ… WebRTC ì„¤ì • ì¡°íšŒ ì™„ë£Œ', 'success');

        // 2. í†µí™” ì‹œì‘ API í˜¸ì¶œ
        log('2. í†µí™” ìƒì„± ì¤‘...', 'info');
        const callRes = await fetch('http://localhost:3000/api/v1/calls', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callerNumber: '01012345678'
          })
        });
        const callData = await callRes.json();
        callId = callData.data.call.id;
        sessionId = callData.data.call.sessionId;
        log(`âœ… í†µí™” ìƒì„± ì™„ë£Œ - Call ID: ${callId}`, 'success');

        // 3. WebSocket ì—°ê²°
        log('3. WebSocket ì‹œê·¸ë„ë§ ì„œë²„ ì—°ê²° ì¤‘...', 'info');
        socket = io('http://localhost:3000/signaling');

        socket.on('connect', () => {
          log('âœ… WebSocket ì—°ê²° ì™„ë£Œ', 'success');
        });

        socket.on('error', (error) => {
          log(`âŒ ì—ëŸ¬: ${error.message}`, 'error');
          updateStatus('âŒ ì—°ê²° ì‹¤íŒ¨', 'error');
        });

        // 4. ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ë° ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ê°€ì ¸ì˜¤ê¸°
        log('4. ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì¤‘...', 'info');
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: false
        });
        log('âœ… ë§ˆì´í¬ ì ‘ê·¼ í—ˆìš©ë¨', 'success');

        // 5. RTCPeerConnection ìƒì„±
        log('5. WebRTC Peer Connection ìƒì„± ì¤‘...', 'info');
        peerConnection = new RTCPeerConnection(rtcConfig);

        // 6. ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì¶”ê°€
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          log(`íŠ¸ë™ ì¶”ê°€: ${track.kind}`, 'info');
        });

        // 7. ì›ê²© ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹  í•¸ë“¤ëŸ¬
        peerConnection.ontrack = (event) => {
          log(`ì›ê²© íŠ¸ë™ ìˆ˜ì‹ : ${event.track.kind}`, 'success');
          remoteAudio.srcObject = event.streams[0];
        };

        // 8. ICE Candidate í•¸ë“¤ëŸ¬
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('ice-candidate', {
              sessionId,
              peerId: 'client-peer',
              candidate: event.candidate
            });
            log('ICE candidate ì „ì†¡', 'info');
          }
        };

        // ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
        peerConnection.oniceconnectionstatechange = () => {
          log(`ICE ì—°ê²° ìƒíƒœ: ${peerConnection.iceConnectionState}`, 'info');
        };

        peerConnection.onconnectionstatechange = () => {
          log(`ì—°ê²° ìƒíƒœ: ${peerConnection.connectionState}`, 'info');
          if (peerConnection.connectionState === 'connected') {
            updateStatus('âœ… AIì™€ í†µí™” ì—°ê²°ë¨! ë§ì”€í•´ë³´ì„¸ìš”.', 'success');
          }
        };

        // 9. ì„¸ì…˜ ì°¸ì—¬
        log('6. ì„¸ì…˜ ì°¸ì—¬ ì¤‘...', 'info');
        socket.emit('join-session', {
          sessionId,
          peerId: 'client-peer',
          callId
        });

        socket.on('joined-session', () => {
          log('âœ… ì„¸ì…˜ ì°¸ì—¬ ì™„ë£Œ', 'success');
        });

        // 10. Offer ìƒì„± ë° ì „ì†¡
        log('7. WebRTC Offer ìƒì„± ì¤‘...', 'info');
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        log('âœ… Local Description ì„¤ì • ì™„ë£Œ', 'success');

        socket.emit('offer', {
          sessionId,
          peerId: 'client-peer',
          offer
        });
        log('âœ… Offer ì „ì†¡ ì™„ë£Œ', 'success');

        // 11. Answer ìˆ˜ì‹ 
        socket.on('answer', async ({ peerId, answer }) => {
          log(`Answer ìˆ˜ì‹  from ${peerId}`, 'success');
          await peerConnection.setRemoteDescription(answer);
          log('âœ… Remote Description ì„¤ì • ì™„ë£Œ', 'success');
        });

        // 12. ICE Candidate ìˆ˜ì‹ 
        socket.on('ice-candidate', async ({ peerId, candidate }) => {
          await peerConnection.addIceCandidate(candidate);
          log(`ICE candidate ìˆ˜ì‹  from ${peerId}`, 'info');
        });

        // 13. AI ì˜¤ë””ì˜¤ ì‘ë‹µ ìˆ˜ì‹ 
        socket.on('ai-audio-response', ({ audioData, timestamp }) => {
          log('ğŸ¤– AI ìŒì„± ì‘ë‹µ ìˆ˜ì‹ !', 'success');

          // Base64 ë””ì½”ë”© ë° ì˜¤ë””ì˜¤ ì¬ìƒ
          const audioBlob = base64ToBlob(audioData, 'audio/mp3');
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio(audioUrl);
          audio.play();
          log('ğŸ”Š AI ì‘ë‹µ ì¬ìƒ ì¤‘...', 'success');
        });

        // 14. í†µí™” ì—°ê²° API í˜¸ì¶œ
        log('8. í†µí™” ì—°ê²° ì¤‘...', 'info');
        await fetch(`http://localhost:3000/api/v1/calls/${callId}/connect`, {
          method: 'POST'
        });
        log('âœ… í†µí™” ì—°ê²° ì™„ë£Œ!', 'success');

        // UI ì—…ë°ì´íŠ¸
        startCallBtn.disabled = true;
        endCallBtn.disabled = false;
        updateStatus('ğŸ™ï¸ í†µí™” ì—°ê²° ì¤‘... AIê°€ ì‘ë‹µí•  ì¤€ë¹„ë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤.', 'info');

      } catch (error) {
        log(`âŒ ì˜¤ë¥˜ ë°œìƒ: ${error.message}`, 'error');
        updateStatus('âŒ ì—°ê²° ì‹¤íŒ¨: ' + error.message, 'error');
        console.error(error);
      }
    };

    // í†µí™” ì¢…ë£Œ
    endCallBtn.onclick = async () => {
      try {
        log('í†µí™” ì¢…ë£Œ ì¤‘...', 'info');

        // 1. í†µí™” ì¢…ë£Œ API í˜¸ì¶œ
        if (callId) {
          await fetch(`http://localhost:3000/api/v1/calls/${callId}/end`, {
            method: 'POST'
          });
          log('âœ… í†µí™” ì¢…ë£Œ API í˜¸ì¶œ ì™„ë£Œ', 'success');
        }

        // 2. PeerConnection ì¢…ë£Œ
        if (peerConnection) {
          peerConnection.close();
          log('âœ… Peer Connection ì¢…ë£Œ', 'success');
        }

        // 3. ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            log(`íŠ¸ë™ ì¤‘ì§€: ${track.kind}`, 'info');
          });
        }

        // 4. WebSocket ì—°ê²° ì¢…ë£Œ
        if (socket) {
          socket.emit('leave-session', { sessionId, peerId: 'client-peer' });
          socket.disconnect();
          log('âœ… WebSocket ì—°ê²° ì¢…ë£Œ', 'success');
        }

        // UI ì—…ë°ì´íŠ¸
        startCallBtn.disabled = false;
        endCallBtn.disabled = true;
        updateStatus('í†µí™” ì¢…ë£Œë¨. ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ "í†µí™” ì‹œì‘"ì„ ëˆ„ë¥´ì„¸ìš”.', 'info');
        log('âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ', 'success');

      } catch (error) {
        log(`âŒ ì¢…ë£Œ ì¤‘ ì˜¤ë¥˜: ${error.message}`, 'error');
        console.error(error);
      }
    };

    // Base64ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
    function base64ToBlob(base64, contentType) {
      const byteCharacters = atob(base64);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], { type: contentType });
    }
  </script>
</body>
</html>
