<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Call - Simple WebSocket</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      text-align: center;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      justify-content: center;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }
    #startCall {
      background: #4CAF50;
      color: white;
    }
    #startCall:hover {
      background: #45a049;
    }
    #startCall:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #endCall {
      background: #f44336;
      color: white;
    }
    #endCall:hover {
      background: #da190b;
    }
    #endCall:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .status {
      padding: 15px;
      margin: 20px 0;
      border-radius: 5px;
      background: #e3f2fd;
      color: #1976d2;
    }
    .status.error {
      background: #ffebee;
      color: #c62828;
    }
    .status.success {
      background: #e8f5e9;
      color: #2e7d32;
    }
    .log {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      max-height: 400px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid #ddd;
      padding-left: 10px;
    }
    .log-entry.info {
      border-color: #2196F3;
    }
    .log-entry.success {
      border-color: #4CAF50;
    }
    .log-entry.error {
      border-color: #f44336;
      color: #c62828;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¤– AI Call (Simple WebSocket)</h1>

    <div class="controls">
      <button id="startCall">ğŸ“ í†µí™” ì‹œì‘</button>
      <button id="endCall" disabled>ğŸ“´ í†µí™” ì¢…ë£Œ</button>
    </div>

    <div id="status" class="status">
      ëŒ€ê¸° ì¤‘... "í†µí™” ì‹œì‘" ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
    </div>

    <h3>ë¡œê·¸</h3>
    <div id="log" class="log"></div>
  </div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    let socket;
    let callId;
    let sessionId;
    let mediaRecorder;
    let audioStream;
    let isRecording = false;

    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ì „ í†µí™” ì •ë¦¬
    window.addEventListener('load', async () => {
      const lastCallId = localStorage.getItem('lastCallId');
      if (lastCallId) {
        log('âš ï¸ ì´ì „ í†µí™” ì„¸ì…˜ ì •ë¦¬ ì¤‘...', 'info');
        try {
          await fetch(`http://localhost:3000/api/v1/calls/${lastCallId}/end`, {
            method: 'POST'
          });
          log('âœ… ì´ì „ í†µí™” ì¢…ë£Œë¨', 'success');
        } catch (e) {
          // ë¬´ì‹œ (ì´ë¯¸ ì¢…ë£Œëœ í†µí™”ì¼ ìˆ˜ ìˆìŒ)
        }
        localStorage.removeItem('lastCallId');
      }
    });

    const startCallBtn = document.getElementById('startCall');
    const endCallBtn = document.getElementById('endCall');
    const statusDiv = document.getElementById('status');
    const logDiv = document.getElementById('log');

    // ë¡œê·¸ í•¨ìˆ˜
    function log(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }

    // ìƒíƒœ ì—…ë°ì´íŠ¸
    function updateStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
    }

    // í†µí™” ì‹œì‘
    startCallBtn.onclick = async () => {
      try {
        log('í†µí™” ì‹œì‘...', 'info');
        updateStatus('ğŸ”„ ì—°ê²° ì¤‘...', 'info');

        // 1. í†µí™” ìƒì„±
        const callRes = await fetch('http://localhost:3000/api/v1/calls', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callerNumber: '01012345678' })
        });

        if (!callRes.ok) {
          const errorData = await callRes.json();

          // 409 ì—ëŸ¬ (ì´ë¯¸ ì§„í–‰ ì¤‘ì¸ í†µí™”)
          if (callRes.status === 409) {
            log('âŒ ì´ë¯¸ ì§„í–‰ ì¤‘ì¸ í†µí™”ê°€ ìˆìŠµë‹ˆë‹¤.', 'error');
            log('ğŸ’¡ í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨(F5)í•˜ê±°ë‚˜ ì„œë²„ë¥¼ ì¬ì‹œì‘í•˜ì„¸ìš”.', 'info');
            updateStatus('âŒ ì´ë¯¸ ì§„í–‰ ì¤‘ì¸ í†µí™”ê°€ ìˆìŠµë‹ˆë‹¤. í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨(F5)í•˜ì„¸ìš”.', 'error');
            return;
          }

          throw new Error(errorData.message || 'Failed to create call');
        }

        const callData = await callRes.json();

        if (!callData.success || !callData.data || !callData.data.call) {
          throw new Error('Invalid response from server');
        }

        callId = callData.data.call.id;
        sessionId = callData.data.call.sessionId;

        // localStorageì— ì €ì¥ (í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ì‹œ ì •ë¦¬ìš©)
        localStorage.setItem('lastCallId', callId);

        log(`âœ… Call created: ${callId}`, 'success');

        // 2. WebSocket ì—°ê²°
        socket = io('http://localhost:3000/signaling');

        socket.on('connect', () => {
          log('âœ… WebSocket connected', 'success');

          // ì„¸ì…˜ ì°¸ì—¬
          socket.emit('join-session', {
            sessionId,
            peerId: 'client-' + Date.now(),
            callId
          });
        });

        // 3. AI ì˜¤ë””ì˜¤ ì‘ë‹µ ìˆ˜ì‹ 
        socket.on('ai-audio-response', ({ audioData }) => {
          log('ğŸ”Š AI ì‘ë‹µ ìˆ˜ì‹ ', 'success');

          // Base64 â†’ Blob â†’ ì¬ìƒ
          const audioBlob = base64ToBlob(audioData, 'audio/mp3');
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio(audioUrl);
          audio.play();

          updateStatus('âœ… AI ì‘ë‹µ ì¬ìƒ ì¤‘...', 'success');
        });

        socket.on('error', (error) => {
          log(`âŒ Error: ${error.message}`, 'error');
          updateStatus('âŒ ì—°ê²° ì‹¤íŒ¨', 'error');
        });

        // 4. ë§ˆì´í¬ ê¶Œí•œ
        log('ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­...', 'info');
        audioStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        log('âœ… ë§ˆì´í¬ í—ˆìš©', 'success');

        // 5. MediaRecorder ì„¤ì •
        mediaRecorder = new MediaRecorder(audioStream, {
          mimeType: 'audio/webm'
        });

        let audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          if (audioChunks.length === 0) return;

          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          audioChunks = [];

          // Blob â†’ ArrayBuffer â†’ Base64
          const arrayBuffer = await audioBlob.arrayBuffer();
          const base64 = arrayBufferToBase64(arrayBuffer);

          log(`ğŸ“¤ ì˜¤ë””ì˜¤ ì „ì†¡ (${audioBlob.size} bytes)`, 'info');

          // WebSocketìœ¼ë¡œ ì˜¤ë””ì˜¤ ì „ì†¡
          socket.emit('user-audio', {
            sessionId,
            callId,
            audioData: base64,
            mimeType: 'audio/webm'
          });
        };

        // 6. ë…¹ìŒ ì‹œì‘ (3ì´ˆë§ˆë‹¤)
        mediaRecorder.start();
        isRecording = true;

        setInterval(() => {
          if (isRecording && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
            setTimeout(() => {
              if (isRecording) {
                mediaRecorder.start();
              }
            }, 100);
          }
        }, 3000);

        // 7. í†µí™” ì—°ê²°
        await fetch(`http://localhost:3000/api/v1/calls/${callId}/connect`, {
          method: 'POST'
        });

        log('âœ… í†µí™” ì—°ê²° ì™„ë£Œ', 'success');
        updateStatus('âœ… AIì™€ ì—°ê²°ë¨! ë§ì”€í•˜ì„¸ìš”.', 'success');

        startCallBtn.disabled = true;
        endCallBtn.disabled = false;

      } catch (error) {
        log(`âŒ ì˜¤ë¥˜: ${error.message}`, 'error');
        updateStatus('âŒ ì—°ê²° ì‹¤íŒ¨', 'error');
      }
    };

    // í†µí™” ì¢…ë£Œ
    endCallBtn.onclick = async () => {
      try {
        log('í†µí™” ì¢…ë£Œ...', 'info');
        isRecording = false;

        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }

        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
        }

        if (socket) {
          socket.emit('leave-session', { sessionId, peerId: 'client-' + Date.now() });
          socket.disconnect();
        }

        if (callId) {
          await fetch(`http://localhost:3000/api/v1/calls/${callId}/end`, {
            method: 'POST'
          });
        }

        // localStorage ì •ë¦¬
        localStorage.removeItem('lastCallId');

        log('âœ… í†µí™” ì¢…ë£Œ', 'success');
        updateStatus('í†µí™” ì¢…ë£Œë¨', 'info');

        startCallBtn.disabled = false;
        endCallBtn.disabled = true;

      } catch (error) {
        log(`âŒ ì¢…ë£Œ ì˜¤ë¥˜: ${error.message}`, 'error');
      }
    };

    // Helper functions
    function base64ToBlob(base64, contentType) {
      const byteCharacters = atob(base64);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], { type: contentType });
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }
  </script>
</body>
</html>
